const { Client, GatewayIntentBits } = require("discord.js");
const {
  joinVoiceChannel,
  VoiceConnectionStatus,
  createAudioReceiver,
} = require("@discordjs/voice");
const prism = require("prism-media");
const fs = require("fs");
const path = require("path");
const { spawn } = require("child_process");
const nodemailer = require("nodemailer");

// Load environment variables
require("dotenv").config();

// Initialize Discord client
const client = new Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildVoiceStates,
    GatewayIntentBits.GuildMembers,
  ],
});

// Configuration
let activeRecordings = new Map();
const COMMANDS_FILE = "voice_commands.json";
const STATUS_FILE = "voice_status.json";
const RECORDINGS_DIR = path.join(__dirname, "recordings");

// Email configuration
let emailTransporter = null;
if (process.env.EMAIL_ADDRESS && process.env.EMAIL_PASSWORD) {
  emailTransporter = nodemailer.createTransport({
    service: "gmail",
    auth: {
      user: process.env.EMAIL_ADDRESS,
      pass: process.env.EMAIL_PASSWORD,
    },
  });
}

// Ensure recordings directory exists
if (!fs.existsSync(RECORDINGS_DIR)) {
  fs.mkdirSync(RECORDINGS_DIR, { recursive: true });
}

// Initialize status file
function initializeStatusFile() {
  const status = {
    status: "ready",
    message: "Node.js voice recorder initialized",
    timestamp: new Date().toISOString(),
  };
  fs.writeFileSync(STATUS_FILE, JSON.stringify(status, null, 2));
}

// Write status update
function updateStatus(status, message, data = {}) {
  const statusObj = {
    status,
    message,
    timestamp: new Date().toISOString(),
    ...data,
  };
  fs.writeFileSync(STATUS_FILE, JSON.stringify(statusObj, null, 2));
  console.log(
    `[${new Date().toISOString()}] ${status.toUpperCase()}: ${message}`,
  );
}

// Convert PCM stream directly to MP3 using FFmpeg
function createPCMToMP3Stream(outputPath) {
  return spawn("ffmpeg", [
    "-f",
    "s16le", // Input format: signed 16-bit little endian
    "-ar",
    "48000", // Sample rate: 48kHz (Discord standard)
    "-ac",
    "2", // Audio channels: stereo
    "-i",
    "-", // Read from stdin
    "-f",
    "mp3", // Output format: MP3
    "-b:a",
    "256k", // Bitrate: 256kbps
    "-loglevel",
    "error", // Minimal logging
    "-y", // Overwrite output file
    outputPath, // Output file
  ]);
}

// Generate filename with proper format: MM_DD_YYYY_HH-MM-SS_{username}_{unique_id}.mp3
function generateFilename(targetUserId, username) {
  const now = new Date();
  const month = String(now.getMonth() + 1).padStart(2, "0");
  const day = String(now.getDate()).padStart(2, "0");
  const year = now.getFullYear();
  const hours = String(now.getHours()).padStart(2, "0");
  const minutes = String(now.getMinutes()).padStart(2, "0");
  const seconds = String(now.getSeconds()).padStart(2, "0");

  // Generate a unique 8-character random identifier
  const uniqueId = Math.random().toString(36).substring(2, 10);

  const safeUsername = username.replace(/[^a-zA-Z0-9_-]/g, "_");
  return `${month}_${day}_${year}_${hours}-${minutes}-${seconds}_${safeUsername}_${uniqueId}.mp3`;
}

// Send email with attachment
async function sendEmailWithRecording(
  filePath,
  targetUsername,
  recipientEmail,
) {
  if (!emailTransporter) {
    throw new Error("Email not configured");
  }

  const mailOptions = {
    from: process.env.EMAIL_ADDRESS,
    to: recipientEmail || process.env.RECIPIENT_EMAIL,
    subject: `Discord Audio Recording - ${targetUsername} - ${new Date().toLocaleDateString()}`,
    text: `Attached is the audio recording for ${targetUsername} from ${new Date().toLocaleString()}.

Recording Details:
- User: ${targetUsername}
- Date: ${new Date().toLocaleString()}
- Duration: Available in audio file
- Format: MP3 (256kbps)

This recording was automatically generated by Discord Audio Archive Bot.`,
    attachments: [
      {
        filename: path.basename(filePath),
        path: filePath,
      },
    ],
  };

  return await emailTransporter.sendMail(mailOptions);
}

// Start voice recording
async function startRecording(guildId, channelId, targetUserId) {
  try {
    updateStatus("connecting", `Attempting to join voice channel ${channelId}`);

    const guild = client.guilds.cache.get(guildId);
    if (!guild) {
      throw new Error(`Guild ${guildId} not found`);
    }

    const channel = guild.channels.cache.get(channelId);
    if (!channel) {
      throw new Error(`Voice channel ${channelId} not found`);
    }

    // Get target user info for filename
    const targetUser = await guild.members.fetch(targetUserId);
    if (!targetUser) {
      throw new Error(`Target user ${targetUserId} not found`);
    }

    // Join voice channel
    const connection = joinVoiceChannel({
      channelId: channelId,
      guildId: guildId,
      adapterCreator: guild.voiceAdapterCreator,
      selfDeaf: false,
      selfMute: true,
    });

    // Wait for connection to be ready
    await new Promise((resolve, reject) => {
      const timeout = setTimeout(
        () => reject(new Error("Connection timeout")),
        15000,
      );

      connection.on(VoiceConnectionStatus.Ready, () => {
        clearTimeout(timeout);
        updateStatus(
          "connected",
          `Successfully connected to voice channel ${channel.name}`,
        );
        resolve();
      });

      connection.on(VoiceConnectionStatus.Disconnected, () => {
        clearTimeout(timeout);
        reject(new Error("Connection failed"));
      });
    });

    // Generate MP3 filename immediately
    const mp3Filename = generateFilename(
      targetUserId,
      targetUser.displayName || targetUser.user.username,
    );
    const mp3FilePath = path.join(RECORDINGS_DIR, mp3Filename);

    // Create FFmpeg process for direct MP3 conversion
    const ffmpegProcess = createPCMToMP3Stream(mp3FilePath);

    // Create audio receiver
    const receiver = connection.receiver;
    const recordingData = {
      connection,
      receiver,
      targetUserId,
      targetUsername: targetUser.displayName || targetUser.user.username,
      guildId,
      channelId,
      startTime: new Date(),
      mp3FilePath,
      ffmpegProcess,
      isRecording: false,
    };

    // Handle FFmpeg process events
    ffmpegProcess.on("close", (code) => {
      if (code === 0) {
        updateStatus("converted", `Audio converted to MP3: ${mp3Filename}`);

        // Send email after successful conversion
        if (emailTransporter && process.env.RECIPIENT_EMAIL) {
          sendEmailWithRecording(
            mp3FilePath,
            recordingData.targetUsername,
            process.env.RECIPIENT_EMAIL,
          )
            .then(() => {
              updateStatus(
                "emailed",
                `Recording emailed successfully: ${mp3Filename}`,
              );
            })
            .catch((emailError) => {
              updateStatus(
                "email_failed",
                `Failed to send email: ${emailError.message}`,
                {
                  file: mp3FilePath,
                },
              );
            });
        } else {
          updateStatus("saved", `Recording saved locally: ${mp3Filename}`);
        }
      } else {
        updateStatus(
          "conversion_failed",
          `FFmpeg conversion failed with code ${code}`,
        );
      }
    });

    ffmpegProcess.on("error", (err) => {
      updateStatus("conversion_error", `FFmpeg error: ${err.message}`);
    });

    // Create a continuous audio stream for the target user immediately
    const audioStream = receiver.subscribe(targetUserId, {
      end: {
        behavior: "manual",
      },
    });

    // Decode Opus to PCM before FFmpeg processing
    const opusDecoder = new prism.opus.Decoder({
      frameSize: 960,
      channels: 2,
      rate: 48000,
    });

    // Pipe: Opus Stream â†’ Decoder â†’ FFmpeg
    audioStream.pipe(opusDecoder).pipe(ffmpegProcess.stdin, { end: false });
    recordingData.currentStream = audioStream;

    // Set up speaking detection for logging purposes
    receiver.speaking.on("start", (userId) => {
      if (userId !== targetUserId) return;
      updateStatus("recording", `${recordingData.targetUsername} is speaking`);
    });

    receiver.speaking.on("end", (userId) => {
      if (userId !== targetUserId) return;
      updateStatus(
        "recording",
        `${recordingData.targetUsername} stopped speaking`,
      );
    });

    activeRecordings.set(guildId, recordingData);
    updateStatus(
      "recording_active",
      `Voice recording active for ${recordingData.targetUsername} in guild ${guildId}`,
    );
  } catch (error) {
    updateStatus("error", `Failed to start recording: ${error.message}`);
  }
}

// Stop voice recording
async function stopRecording(guildId) {
  try {
    const recordingData = activeRecordings.get(guildId);
    if (!recordingData) {
      updateStatus("warning", `No active recording found for guild ${guildId}`);
      return;
    }

    updateStatus(
      "stopping",
      `Stopping recording for ${recordingData.targetUsername}`,
    );

    // End current audio stream if exists
    if (recordingData.currentStream) {
      recordingData.currentStream.destroy();
    }

    // Close FFmpeg input to finalize MP3 file
    if (recordingData.ffmpegProcess && recordingData.ffmpegProcess.stdin) {
      recordingData.ffmpegProcess.stdin.end();
    }

    // Disconnect from voice channel
    recordingData.connection.destroy();

    // Clean up
    activeRecordings.delete(guildId);

    const duration = new Date() - recordingData.startTime;
    const durationMinutes = Math.round(duration / 1000 / 60);

    updateStatus(
      "stopped",
      `Recording stopped for ${recordingData.targetUsername} after ${durationMinutes} minutes`,
    );
  } catch (error) {
    updateStatus("error", `Failed to stop recording: ${error.message}`);
  }
}

// Monitor commands file
function monitorCommands() {
  if (!fs.existsSync(COMMANDS_FILE)) {
    return;
  }

  try {
    const data = fs.readFileSync(COMMANDS_FILE, "utf8");
    const command = JSON.parse(data);

    // Process command
    if (command.action === "start_recording") {
      startRecording(command.guildId, command.channelId, command.targetUserId);
    } else if (command.action === "stop_recording") {
      stopRecording(command.guildId);
    }

    // Clear processed command
    fs.unlinkSync(COMMANDS_FILE);
  } catch (error) {
    updateStatus("command_error", `Error processing command: ${error.message}`);
  }
}

// Bot ready event
client.once("ready", () => {
  console.log(`ðŸŽ™ï¸ Voice recorder logged in as ${client.user.tag}`);
  console.log(`ðŸ“§ Email configured: ${emailTransporter ? "Yes" : "No"}`);
  console.log(`ðŸ“ Recordings directory: ${RECORDINGS_DIR}`);

  initializeStatusFile();

  // Monitor commands file every second
  setInterval(monitorCommands, 1000);

  updateStatus("ready", "Voice recorder ready for commands");
});

// Handle errors
client.on("error", (error) => {
  updateStatus("client_error", `Discord client error: ${error.message}`);
});

process.on("unhandledRejection", (error) => {
  updateStatus("unhandled_error", `Unhandled rejection: ${error.message}`);
});

process.on("uncaughtException", (error) => {
  updateStatus("uncaught_error", `Uncaught exception: ${error.message}`);
  process.exit(1);
});

// Graceful shutdown
process.on("SIGINT", () => {
  console.log("ðŸ›‘ Shutting down voice recorder...");

  // Stop all active recordings
  activeRecordings.forEach((recordingData, guildId) => {
    stopRecording(guildId);
  });

  client.destroy();
  process.exit(0);
});

// Login to Discord
client.login(process.env.DISCORD_TOKEN).catch((error) => {
  updateStatus("login_error", `Failed to login: ${error.message}`);
  process.exit(1);
});
